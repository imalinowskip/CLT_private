import Clt.CharFun
import Clt.Inversion

noncomputable section

open Mathlib MeasureTheory ProbabilityTheory Topology Filter Vector Complex Isometry BoundedContinuousFunction Finset RealInnerProductSpace

open scoped NNReal

variable {╬Е : Type*} [MeasurableSpace ╬Е] --[TopologicalSpace ╬Е]
variable {P : ProbabilityMeasure ╬Е}
variable {d : РёЋ+}
variable {X : ╬Е Рєњ EuclideanSpace РёЮ (Fin d)}
variable {Xn : РёЋ Рєњ ╬Е Рєњ EuclideanSpace РёЮ (Fin d)}

instance : MeasurableSpace (EuclideanSpace РёЮ (Fin d)) := inferInstance

lemma measurable_dotProduct_shorter (hX : Measurable X) (t : EuclideanSpace РёЮ (Fin d)):
  Measurable (fun ¤Ѕ : ╬Е => РЪф(X ¤Ѕ), tРЪФ) :=
  Measurable.inner_const hX

lemma aemeasurable_dotProduct {╬╝ : Measure ╬Е} (hX : Measurable X) (t : EuclideanSpace РёЮ (Fin d)):
  AEMeasurable (fun ¤Ѕ : ╬Е => РЪф(X ¤Ѕ), tРЪФ) ╬╝ :=
  (measurable_dotProduct_shorter hX t).aemeasurable

lemma continuous_exp_ofReal_mul_I : Continuous (fun u : РёЮ => Complex.exp (u * Complex.I))
  := continuous_exp.comp (Continuous.mul continuous_ofReal continuous_const)

lemma complex_dist_zero_eq_abs (z : Рёѓ) : dist z 0 = РђќzРђќ :=
calc
  dist z 0 = Рђќz - 0Рђќ := rfl
  _ = РђќzРђќ := by rw [sub_zero]

lemma complex_dist_zero_eq_abs' (z : Рёѓ) : dist 0 z = РђќzРђќ :=
by rw [dist_comm, complex_dist_zero_eq_abs z]

lemma cexp_bound_exact : Рѕђ (u v : РёЮ), dist (Complex.exp (РєЉu * I)) (Complex.exp (РєЉv * I)) РЅц 2 :=
  fun u v =>
    calc
      dist (Complex.exp (РєЉu * I)) (Complex.exp (РєЉv * I))
        РЅц dist (Complex.exp (РєЉu * I)) 0 + dist 0 (Complex.exp (РєЉv * I)) := dist_triangle _ _ _
      _ = РђќComplex.exp (РєЉu * I)Рђќ + РђќComplex.exp (РєЉv * I)Рђќ := by rw [complex_dist_zero_eq_abs, complex_dist_zero_eq_abs']
      _ = 1 + 1 := by rw [norm_exp_ofReal_mul_I, norm_exp_ofReal_mul_I]
      _ = 2 := by norm_num

def bounded_continuous_exp_ofReal_mul_I : РёЮ РєњрхЄ Рёѓ :=
  BoundedContinuousFunction.mkOfBound РЪеfun u => Complex.exp (u * Complex.I), continuous_exp_ofReal_mul_IРЪЕ 2 cexp_bound_exact

def bounded_continuous_exp_inner_mul_I (t : EuclideanSpace РёЮ (Fin d)) : EuclideanSpace РёЮ (Fin d) РєњрхЄ Рёѓ :=
  BoundedContinuousFunction.compContinuous bounded_continuous_exp_ofReal_mul_I РЪеfun x => РЪфx, tРЪФ,
    continuous_id.inner continuous_constРЪЕ

@[simp] lemma bounded_continuous_exp_ofReal_mul_I_eq_cexp (u : РёЮ) :
  bounded_continuous_exp_ofReal_mul_I u = Complex.exp (u * Complex.I) :=
rfl

lemma charFun_tendsto_if_inner_tendsto (hX : Measurable X) (hXn : Рѕђ n, Measurable (Xn n)):
  (Рѕђ t : EuclideanSpace РёЮ (Fin d), Tendsto (fun n : РёЋ => P.map (aemeasurable_dotProduct (hXn n) t)) atTop (­ЮЊЮ (P.map (aemeasurable_dotProduct hX t)))) Рєњ (Рѕђ t : EuclideanSpace РёЮ (Fin d), Tendsto (fun n Рєд charFun (P.map (hXn n).aemeasurable) t) atTop (­ЮЊЮ (charFun (P.map hX.aemeasurable) t))) :=
  by
    intros hconv t
    let ¤є := bounded_continuous_exp_inner_mul_I t

    have h_eq3 : charFun (P.map hX.aemeasurable) t = РѕФ x, Complex.exp (РЪфX x, tРЪФ * Complex.I) РѕѓP :=
      by
        simp only [charFun]
        apply MeasureTheory.integral_map
        ┬и exact hX.aemeasurable
        ┬и exact ¤є.continuous.stronglyMeasurable.aestronglyMeasurable
    have h_eq_final : charFun (P.map hX.aemeasurable) t = РѕФ x, Complex.exp (x * Complex.I) Рѕѓ(P.map (aemeasurable_dotProduct hX t)).toMeasure :=
      by
        rw [h_eq3]
        rw [eq_comm]
        apply MeasureTheory.integral_map
        ┬и exact (aemeasurable_dotProduct hX t)
        ┬и exact continuous_exp_ofReal_mul_I.stronglyMeasurable.aestronglyMeasurable

    have h_eq_n : Рѕђ n, charFun (P.map (hXn n).aemeasurable) t = РѕФ x, ¤є (Xn n x) РѕѓP := by
      intro n
      simp only [charFun]
      apply MeasureTheory.integral_map
      ┬и exact (hXn n).aemeasurable
      ┬и exact ¤є.continuous.stronglyMeasurable.aestronglyMeasurable
    have h_eq_n_final : Рѕђ n, charFun (P.map (hXn n).aemeasurable) t = РѕФ x, Complex.exp (x * Complex.I) Рѕѓ(P.map (aemeasurable_dotProduct (hXn n) t)).toMeasure :=
      by
        intro n
        rw [h_eq_n]
        rw [eq_comm]
        apply MeasureTheory.integral_map
        ┬и exact (aemeasurable_dotProduct (hXn n) t)
        ┬и exact continuous_exp_ofReal_mul_I.stronglyMeasurable.aestronglyMeasurable

    let ¤ѕ := bounded_continuous_exp_ofReal_mul_I
    let ¤ѕ_re := (fun u => (¤ѕ u).re)
    let ¤ѕ_im := (fun u => (¤ѕ u).im)

    let ¤ѕ_re_bcf_bound_exact : Рѕђ (u v : РёЮ), dist (¤ѕ_re u) (¤ѕ_re v) РЅц 2 := fun u v =>
    calc
      dist (¤ѕ_re u) (¤ѕ_re v)
        РЅц dist (¤ѕ_re u) 0 + dist 0 (¤ѕ_re v) := dist_triangle _ _ _
      _ = |¤ѕ_re u| + |¤ѕ_re v| := by rw [Real.dist_0_eq_abs, dist_comm, Real.dist_0_eq_abs]
      _ = Рђќ¤ѕ_re uРђќ + Рђќ¤ѕ_re vРђќ := by rw [Real.norm_eq_abs, Real.norm_eq_abs]
      _ РЅц Рђќ¤ѕ uРђќ + Рђќ¤ѕ vРђќ :=
      by
        simp [¤ѕ_im]
        exact add_le_add (RCLike.norm_re_le_norm (¤ѕ u)) (RCLike.norm_re_le_norm (¤ѕ v))
      _ = РђќComplex.exp (u * Complex.I)Рђќ + РђќComplex.exp (v * Complex.I)Рђќ := by simp [¤ѕ, ¤ѕ]
      _ = 1 + 1 := by rw [norm_exp_ofReal_mul_I, norm_exp_ofReal_mul_I]
      _ = 2 := by norm_num
    let ¤ѕ_im_bcf_bound_exact : Рѕђ (u v : РёЮ), dist (¤ѕ_im u) (¤ѕ_im v) РЅц 2 := fun u v =>
    calc
      dist (¤ѕ_im u) (¤ѕ_im v)
        РЅц dist (¤ѕ_im u) 0 + dist 0 (¤ѕ_im v) := dist_triangle _ _ _
      _ = |¤ѕ_im u| + |¤ѕ_im v| := by rw [Real.dist_0_eq_abs, dist_comm, Real.dist_0_eq_abs]
      _ = Рђќ¤ѕ_im uРђќ + Рђќ¤ѕ_im vРђќ := by rw [Real.norm_eq_abs, Real.norm_eq_abs]
      _ РЅц Рђќ¤ѕ uРђќ + Рђќ¤ѕ vРђќ :=
      by
        simp [¤ѕ_im]
        exact add_le_add (RCLike.norm_im_le_norm (¤ѕ u)) (RCLike.norm_im_le_norm (¤ѕ v))
      _ = РђќComplex.exp (u * Complex.I)Рђќ + РђќComplex.exp (v * Complex.I)Рђќ := by simp [¤ѕ, ¤ѕ]
      _ = 1 + 1 := by rw [norm_exp_ofReal_mul_I, norm_exp_ofReal_mul_I]
      _ = 2 := by norm_num

    let ¤ѕ_re_bcf : РёЮ РєњрхЄ РёЮ := BoundedContinuousFunction.mkOfBound РЪе¤ѕ_re, Continuous.comp continuous_re ¤ѕ.continuousРЪЕ 2 ¤ѕ_re_bcf_bound_exact
    let ¤ѕ_im_bcf : РёЮ РєњрхЄ РёЮ := BoundedContinuousFunction.mkOfBound РЪе¤ѕ_im, Continuous.comp continuous_im ¤ѕ.continuousРЪЕ 2 ¤ѕ_im_bcf_bound_exact

    let ¤ѕ_decomp (x : РёЮ) : ¤ѕ x = ¤ѕ_re_bcf x + (¤ѕ_im_bcf x) * Complex.I :=
      by
        simp [¤ѕ_re_bcf, ¤ѕ_im_bcf]
        rw [Complex.re_add_im]

    let h_lim (f : РёЮ РєњрхЄ РёЮ) : 0 РЅц f Рєњ atTop.limsup (fun n => РѕФ x, f x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct (hXn n) t)))) РЅц РѕФ x, f x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct hX t))) :=
      by
        intro f_nn
        let ╬╝РѓЎ : РёЋ Рєњ ProbabilityMeasure РёЮ :=
          fun n => (P.map (aemeasurable_dotProduct (hXn n) t) : ProbabilityMeasure РёЮ)
        let ╬╝ : ProbabilityMeasure РёЮ :=
          (P.map (aemeasurable_dotProduct hX t) : ProbabilityMeasure РёЮ)
        let hconv_t : Tendsto ╬╝РѓЎ atTop (­ЮЊЮ ╬╝)
          := hconv t
        have hf : Tendsto (fun n => РѕФ x, f x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct (hXn n) t)))) atTop
                        (­ЮЊЮ (РѕФ x, f x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct hX t))))) :=
          by
            have h_iff := @ProbabilityMeasure.tendsto_iff_forall_integral_tendsto РёЮ _ _ _ РёЋ atTop ╬╝РѓЎ ╬╝
            have h_rhs := Iff.mp h_iff hconv_t
            exact h_rhs f

        exact le_of_eq (Tendsto.limsup_eq hf)

    have integralConv_re :
      Tendsto (fun n => РѕФ (x : РёЮ), ¤ѕ_re_bcf x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct (hXn n) t)))) atTop (­ЮЊЮ (РѕФ (x : РёЮ), ¤ѕ_re_bcf x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct hX t))))) := BoundedContinuousFunction.tendsto_integral_of_forall_limsup_integral_le_integral h_lim ¤ѕ_re_bcf

    have integralConv_im :
      Tendsto (fun n => РѕФ (x : РёЮ), ¤ѕ_im_bcf x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct (hXn n) t)))) atTop (­ЮЊЮ (РѕФ (x : РёЮ), ¤ѕ_im_bcf x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct hX t)))) ) :=
      BoundedContinuousFunction.tendsto_integral_of_forall_limsup_integral_le_integral h_lim ¤ѕ_im_bcf

    have h_mul_one : Рѕђ x, x * Complex.ofReal 1 = x := by simp

    have h_integral_smul_const_¤ѕ_re_bcf : Рѕђ (╬й : Measure РёЮ), РѕФ x, ¤ѕ_re_bcf x * Complex.ofReal 1 Рѕѓ ╬й = (РѕФ x, ¤ѕ_re_bcf x Рѕѓ ╬й) * Complex.ofReal 1 :=
    by
      intro ╬й
      exact integral_smul_const ¤ѕ_re_bcf (Complex.ofReal 1)
    have h_integral_smul_const_¤ѕ_im_bcf : Рѕђ (╬й : Measure РёЮ), РѕФ x, ¤ѕ_im_bcf x * Complex.I Рѕѓ ╬й = (РѕФ x, ¤ѕ_im_bcf x Рѕѓ ╬й) * Complex.I :=
    by
      intro ╬й
      exact integral_smul_const ¤ѕ_im_bcf (Complex.I)

    have h_¤ѕ : Рѕђ (╬й : ProbabilityMeasure РёЮ), РѕФ x, ¤ѕ x Рѕѓ ╬й = РѕФ x, ¤ѕ_re_bcf x Рѕѓ ╬й + (РѕФ x, ¤ѕ_im_bcf x Рѕѓ ╬й) * Complex.I :=
      by
        intro ╬й
        have h : Рѕђ x, ¤ѕ x = (¤ѕ_re_bcf x) * Complex.ofReal 1 + (¤ѕ_im_bcf x) * Complex.I := by
          intro x
          rw [h_mul_one]
          exact ¤ѕ_decomp x
        rw [integral_congr_ae (Eventually.of_forall h), integral_add]

        rw [h_integral_smul_const_¤ѕ_re_bcf ╬й]
        rw [h_integral_smul_const_¤ѕ_im_bcf ╬й]
        rw [h_mul_one]

        simp [h_mul_one]

        have h_¤ѕ_re_bcf_integ : Integrable ¤ѕ_re_bcf ╬й := BoundedContinuousFunction.integrable ╬й ¤ѕ_re_bcf
        have h_c_¤ѕ_re_bcf_integ : Integrable (fun a => (¤ѕ_re_bcf a : Рёѓ)) РєЉ╬й := by exact h_¤ѕ_re_bcf_integ.ofReal
        exact h_c_¤ѕ_re_bcf_integ

        have h_¤ѕ_im_bcf_integ : Integrable ¤ѕ_im_bcf ╬й := BoundedContinuousFunction.integrable ╬й ¤ѕ_im_bcf
        have h_c_¤ѕ_im_bcf_integ : Integrable (fun a => (¤ѕ_im_bcf a : Рёѓ)) РєЉ╬й := by exact h_¤ѕ_im_bcf_integ.ofReal

        exact h_¤ѕ_im_bcf_integ.ofReal.mul_const Complex.I

    have integralConv :
      Tendsto (fun n => РѕФ (x : РёЮ), ¤ѕ x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct (hXn n) t)))) atTop (­ЮЊЮ (РѕФ (x : РёЮ), ¤ѕ x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct hX t))))) :=
        by
          rw [h_¤ѕ]
          have h1 : Tendsto (fun n => Complex.ofReal (РѕФ (x : РёЮ), ¤ѕ_re_bcf x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct (hXn n) t))))) atTop
            (­ЮЊЮ (РєЉ(РѕФ (x : РёЮ), ¤ѕ_re_bcf x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct hX t)))))) :=
            Tendsto.ofReal integralConv_re
          have h2 : Tendsto (fun n => Complex.ofReal (РѕФ (x : РёЮ), ¤ѕ_im_bcf x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct (hXn n) t))))) atTop
            (­ЮЊЮ (РєЉ(РѕФ (x : РёЮ), ¤ѕ_im_bcf x Рѕѓ (РєЉ(P.map (aemeasurable_dotProduct hX t)))))) :=
            Tendsto.ofReal integralConv_im
          have h3 := Tendsto.mul h2 (tendsto_const_nhds : Tendsto (fun _ => Complex.I) atTop (­ЮЊЮ Complex.I))
          have h4 := Tendsto.add h1 h3

          have : Рѕђ n, РѕФ x, ¤ѕ x Рѕѓ(РєЉ(P.map (aemeasurable_dotProduct (hXn n) t))) =
                        РѕФ x, ¤ѕ_re_bcf x Рѕѓ(РєЉ(P.map (aemeasurable_dotProduct (hXn n) t))) +
                        (РѕФ x, ¤ѕ_im_bcf x Рѕѓ(РєЉ(P.map (aemeasurable_dotProduct (hXn n) t)))) * Complex.I :=
            fun n => h_¤ѕ _
          refine Tendsto.congr' ?_ h4
          simp_rw [this]
          simp [EventuallyEq.of_eq]

    rw [h_eq_final]

    have h_char_eq_n : Рѕђ n, charFun (P.map (hXn n).aemeasurable) t = РѕФ x, ¤ѕ x Рѕѓ(РєЉ(P.map (aemeasurable_dotProduct (hXn n) t))) :=
      fun n => h_eq_n_final n РќИ rfl

    have h_char_eq_lim : charFun (P.map hX.aemeasurable) t = РѕФ x, ¤ѕ x Рѕѓ(РєЉ(P.map (aemeasurable_dotProduct hX t))) :=
      h_eq_final

    simp_rw [h_char_eq_n]

    have h¤ѕ_eq_cexp : (fun x : РёЮ => ¤ѕ x) = (fun x : РёЮ => Complex.exp (x * Complex.I)) := by
      ext x
      rfl

    have h_lim_eq : РѕФ x, Complex.exp (x * Complex.I) Рѕѓ((P.map (aemeasurable_dotProduct hX t)).toMeasure) =
                РѕФ x, ¤ѕ x Рѕѓ(РєЉ(P.map (aemeasurable_dotProduct hX t))) :=
      by rw [Рєљ h¤ѕ_eq_cexp]

    rw [h_lim_eq]
    exact integralConv

lemma rv_tendsto_if_charFun_tendsto (hX : Measurable X) (hXn : Рѕђ n, Measurable (Xn n)):
  (Рѕђ t : EuclideanSpace РёЮ (Fin d), Tendsto (fun n Рєд charFun (P.map (hXn n).aemeasurable) t) atTop (­ЮЊЮ (charFun (P.map hX.aemeasurable) t))) Рєњ Tendsto (fun n Рєд P.map (hXn n).aemeasurable) atTop (­ЮЊЮ (P.map hX.aemeasurable)) :=
  by
    intro h
    let ╬╝ := P.map hX.aemeasurable
    let ╬╝РѓЎ := fun n => P.map (hXn n).aemeasurable
    exact MeasureTheory.ProbabilityMeasure.tendsto_iff_tendsto_charFun.mpr h

theorem cramerWold (hX : Measurable X) (hXn : Рѕђ n, Measurable (Xn n)) :
  (Рѕђ t : EuclideanSpace РёЮ (Fin d), Tendsto (fun n : РёЋ => P.map (aemeasurable_dotProduct (hXn n) t)) atTop (­ЮЊЮ (P.map (aemeasurable_dotProduct hX t)))) Рєњ (Tendsto (fun n : РёЋ => P.map (hXn n).aemeasurable) atTop (­ЮЊЮ (P.map hX.aemeasurable)))
  := by
  intro h
  exact (rv_tendsto_if_charFun_tendsto hX hXn) ((charFun_tendsto_if_inner_tendsto hX hXn) (h))

#min_imports
